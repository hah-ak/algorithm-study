완전검색(Exhaustive Search)
    -모든 경우를 탐색하여 답을 찾는 방식
    -완전검색으로 답을 찾고 성능개선을 하는 방식으로 사용할 수 있다.
    -순열을 만들때 사용 할수있다.
탐욕법(Greedy algorithm)
    -최적해를 구하는 근시안적 방법.
    -여러 해 중 그 단계에서 최적이라 판단되는 해를 선택해서 이어나가는 방식
    -즉, 각 단계에서 최적의 해를 찾을 뿐, 최종적으로 최적의 해가 항상 나오지는 않는다.
    수행과정 
        1.해 선택 : 한 단계가 진행되고 최적의 해를 구한다음, 부분 해의 집합에 추가
        2.실행가능성 검증 : 그리고 이 해가 문제에 위반하는 부분이 있는지 검증.
        3.해 검사 : 문제의 해가 가능한지 검증, 최종 해가 아니라면 다시 해 선택부터 시작.
정렬(sort)
    1. 버블정렬
        - 인접한 두수의 크기를 비교하는 방식 O(n**2)
    2. 카운팅정렬
        - 각 숫자의 갯수와 인댁스를 활용한 방식이다.
        - 서로 다른 숫자들의 갯수만큼 리스트를 만들고 각 자리에 가장 작은 숫자부터 갯수를 누적시켜서 쓴 리스트를 만든다.
        - 이때 이 리스트의 인덱스가 어떤 숫자 자체를 뜻하게 되고 써진 숫자는 그 숫자가 들어갈 인댁스를 뜻하게 된다.
        - 정수에만 사용할 수 있는 방식이다.
        - O(n+k),n은 리스트원소의 갯수, k는 최고 숫자
    3. 셀렉션알고리즘(선택정렬)
        - 가장 큰,작은 수를 선택해 가장 앞의 숫자와 바꾼 후, 그 다음 값들과 자리에서 마찬가지 방식으로 행해짐.
패턴매칭
    -본문에서 특정 문자를 찾는 알고리즘
    1. Brute Force
        - 본문 문자를 전부 순회, 일일이 비교하는 방식
    2. KMP
        - 불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 알고, 그 부분에 대해서 비교 수행을 하지 않음.
        - 전처리 필요
        - 매칭 실패시 돌아갈 곳을 계산.
    3. 보이어-무어
        - 오른쪽에서 왼쪽으로 찾는다. 대부분 상용 소프트웨어 에서 사용
        - 찾을 문자를 이용해 불일치시 얼마만큼 스킵할 건지 미리 정해 놓는다.
Stack algorithm
    memoization
        스택에서 재귀호출시 중복 계산이 많은 경우의 단점을 개선하기위해 필요
        이전에 계산한 값을 메모리에 미리 저장해 다시 계산하지 않도록 하는 방식이다
        DP(동적계획법)의 핵심이 되는 기술
    DynamicProgramming
        문제를 부분문제로 나누고
        가장 작은부분부터 실행해
        해를 테이블에 저장하
        부분문제의 해를 이용해 문제를 풀어나가는 방식
        recursive(재귀)방식 : 식은 쉬우나 overhead가 발생할 수 있음
        iterative방식 : 성능에서는 재귀보다 효율 적일 수있다.
    DFS(깊이 우선 탐색)
        시작 점부터 더 이상 길이 없는 정점까지 간후
        최후 정점 이전으로 돌아가 다른 길로가 또다른 정점을 방문하는 방식을 반복해
        모든 정점을 순회하는 방식
        방식
            1. 시작정점을 하나선택
            2. 방문하지 않은 정점이 있다면 시작정점을 스택에 push하고 다른 정점에 방문
            3. 이 다른 정점을 시작정점으로하여 1부터 반복
            4. 모든 곳을 방문했다면, 탐색방향을 바꾸기 위해 이 스택(의 탑을) pop하여 받은 가장 마지막
            정점을 시작점으로하여 1번부터 시작
        좀더 쉽게 말하자면
            1. 시작하는 스택을 쌓는다
            2. 스택에 가장 위에 있는 [-1]번째 원소가 자식을 가진다면 [-1]번째를 pop하고 그 원소들을 스택에 push한다
            3. 만약 [-1]번째 원소가 자식이 없다면 pop만 해준다.
            4. 다시 쌓인 스택에서 마찬가지로 2~3번을 진행한다
            5. 최종적으로 스택이 0이 될때까지(혹은 원하는 답을 찾을 때까지) 2~4번을 진행한다.
    백트래킹(backtracking)(logn 최대 n^^2)
        - 어떤 노드에서 출발하는 경로가 답이 안나올것 같으면 더이상 그경로르 가지 않음
        - DFS와 비슷하나 가지치기라는 점에서 다르다.(위의 이유)
        - Prunning이라고함
        - 그래서 경우의 수를 줄일 수 있음.
        - 모든 후보를 탐색하지 않음
    분할정복(divide and conqure)(log2n)
        - 문제를 분할해 해결한다음 최종적으로 병합
        - 퀵정렬

Queue
    - BFS
        시작점의 인접한 정점들은 모두 방문 후, 방문했던 정점을 시작으로 
        다시 인접한 정점들을 방문
Tree
        - 비선형 1:n의 구조, 원소들간 계층으로 나뉨
        - 한개이상의 노드 중 최상위
        - 루트 노드는 시작점
        - 형재노드는 같은 부모노드의 자식노드
        - 간선을 따라 루트까지 길에 존재하는 모든 노드
        - 서브 트리는 부모와 연결을 끊어서 생기는 노드
        - 서브트리의 하위노드
        - 차수는 해당노드에 연결된 자식노드
        - 트리의 차수는 트리에서 가장큰 차수
        - 단말노드(리프노드)는 자식이 없는(차수가 0)인 노드
        - 높이는 루에서 노드까지의 간선을 높이라함(루트를 0으로 시작)
        - 트리의 높이는 가장 큰 높이를 듯함
    - binary tree(이진트리)
        - 모든 노드들이 2개의 서브트리를 가짐
        - 포화 이진트리(full binary tree)
            - node의 갯수 : 2^(h+1)-1(만약 높이가 1부터 시작이라면 h)
            - 모두 순서대로 각자의 번호를 가진다
            - 만약 노드가 10개인 포화이진트리를 그린다면, 자식이 1개인 노드가 존재
            - 10까지 빈공간 없는 트리가 된다
        - skewed binary tree(편향이진트리)
            - 한쪽방향으로 자식하나만 진행하는 트리
    - 트리의 순회(traversal)
            - 트리를 전부 도는 방법. 트리는 비선형 구조라 전후관계를 알 수 없다.
            - ( BFS, DFS와는 분명히 다르다.)
        - preorder traversal(전위순회)
            - 루트먼저 들러서 자식노드 순회
            - 루트 > 왼쪽 > 오른쪽 순 
            - 각 노드, 노드의 왼쪽 자손, 그다음 오른쪽 자손 순이므로 높이1의 왼쪽 서브트리 하나가 끝나면 바로 
              그 옆의 오른쪽 서브트리가 검색되는 순서이다.
        - inorder traversal(중위순회)
            - 왼쪽, 루트, 오른쪽 순으로 순회
            - 가장 왼쪽 노드를 시작으로 그 노드의 부모 노드를 간후 오른쪽 자식노드로 간다.
              만약 오른쪽 노드가 자식이 있다면 이 노드를 부모로 왼쪽 자식노드부터 방문한다.
              그리고 처음 오른쪽 노드를 방문후 자식 오른쪽노드를 방문한다. 이렇게 되면 이 서브트리는 모두 방문한게되고
              최초 노드의 부모노드의 부모노드로 가서 이 노드의 오른쪽 자식을 방문하는 형태이다
        - postorder traversal(후위 순회)
            - 자손노드먼저 들러서 루트로 순회
            - 최초 왼쪽 자식을 들리고 그 노드에 자식을 모두 방문하면 오른 쪽 자식먼저 들리고 부모로 가는 방식.
    - 트리의 표현
        - 각 노드에 번호를 매길수 있다는 점을 이용한다
        - 자식노드는 부모 노드의 *2 , *2+1 이된다.(반대로 생각할 수 있음)
        - 노드 번호를 인댁스로 이용하여 리스화가 가능해진다.
        - 단 평향트리의 경우 빈공간이 발생하게 된다.(한쪽만 사용하는 트리이다보니 꽉차지 않은 형태이기에 발생)
        - 이 경우 연결리스트를 이용할 수 있다.
    - binary Search tree
        - 노드를 기준으로 작은 수는 왼쪽, 큰수는 오른쪽에 두어 2진트리 형태를 쭈욱 만들어가는 형태
        - 중위 순회를 이용할 수있다.
        - 평균적으로 log n의 시간이 걸린다.
Heap
    - 완전 이진트리에서 키값이 가장 크거나 작은 것을 찾기위해 만든 구조
    - 키값이 중복되어서는 안된다.
    - 삭제는 루트노드만 가능하다.
    - 루트 노드가 삭제되면 가장 끝자리 수를 루트로 올리고 자리에 맞는지 확인 후 변경 및 종료.
    - 이를 이용해 우선순위 큐를 만들수 있다.